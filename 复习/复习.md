# 高级程序设计复习

## 数据抽象与封装

 * **数据抽象**——数据的使用者只需要知道对数据所能实施的操作以及这些操作之间的关系，而不必知道数据的具体表示形式
 * **数据封装**——指把数据及其操作作为一个整体来进行描述。数据的具体表示对使用者是不可见的（封装），对数据的访问（使用）只能通过封装体所提供的对外接口（操作）来完成。 
* **过程式程序设计的特点**
  * 以功能为中心，强调过程（功能）抽象，但数据与操作分离，二者联系松散。
  * 实现了操作的封装，但数据是公开的，数据缺乏保护。
  * 按子程序划分模块，模块边界模糊。
  * 子程序往往针对某个程序而设计，这使得程序难以复用。
  * 功能易变，程序维护困难。
  * 基于功能分解的解题方式与问题空间缺乏对应。
* **面向对象程序设计的特点**
  * 以数据为中心，强调数据抽象，操作依附于数据，二者联系紧密。
  * 实现了数据的封装，加强了数据的保护。
  * 按对象类划分模块，模块边界清晰。
  * 对象（类）往往具有通用性，再加上继承机制，使得程序容易复用。
  * 对象（类）相对稳定，有利于程序维护。
  * 基于对象/类的解题方式与问题空间有很好的对应。
* **面向对象程序特有的多态**
  * **对象类型的多态**：子类对象既属于子类，也属于父类。
  * **对象标识的多态**：父类的引用或指针可以引用或指向父类对象，也可以引用或指向子类对象。
  * **消息的多态**：发给父类对象的消息也可以发给子类对象，即，一个消息集有多种解释（父类与子类有不同解释）。
  * **继承产生的多态**：上述三种在继承的时候产生了多态。   
* **绑定**：确定对多态元素的某个使用是多态元素的那一种形式。
  * 静态绑定（StaticBinding，也称前期绑定，EarlyBinding）：在编译时刻确定。
  * 动态绑定（DynamicBinding，也称后期绑定或延迟绑定，LateBinding）：在运行时刻确定。 
* **多态带来的好处**：
  * 易于实现程序高层（上层）代码的复用。
  * 使得程序扩充变得容易（只要增加底层的具体实现）。
  * 增强语言的可扩充性（操作符重载等）。 



## 对象与类

* ###对象/类(Object&Class)


* 对象是由数据及能对其实施的操作所构成的封装体，它属于值的范畴。
* 类描述了对象的特征（包含哪些数据和操作），它属于类型的范畴（对象的类型）。 
  * **数据**：数据成员、成员变量、成员函数的局部变量等
    * 数据成员是对类的对象所包含的数据描述，它们可以是常量和变量。
  * **操作**：成员函数、方法、消息处理过程等


* 在说明一个数据成员的类型时，如果未见到相应类型的定义，或相应的类型未定义完，则该数据成员的类型只能是这些类型的指针或引用类型。

* 成员函数的实现（函数体）可以放在类定义中，例如：

  ```c++
  class A {  ...
     	 void f() {...} //建议编译器按内联函数处理。
  	};
  	成员函数的实现也可以放在类定义外，例如：
  	class A {  ...
  	    void f(); //声明
  	};
  	void A::f() {... } //需要用类名受限，区别于全局函数。
  ```

* 类中的成员函数对该类的每个对象有几个拷贝呢？只有一个

* ###对象的初始化和消亡前处理

  * **拷贝构造函数**：在创建一个对象时，若用另一个同类型的对象对其初始化，这时将会调用一个特殊的构造函数：拷贝构造函数。

  * **在三种情况下，会调用类的拷贝构造函数：**

    **定义对象时，例如：**

    ==A a1;== 

    ==A a2(a1);  //也可写成：A a2=a1; 或：A a2=A(a1);==

      ==//调用A的拷贝构造函数，用对象a1初始化对象a2，==

    **把对象作为值参数传给函数时，例如：**

    ==voidf(A x);==

    ==A a;==

    ==f(a);  //调用f时将创建形参对象x，并调用A的拷贝构造函数，==

    * ==//用对象a对x进行初始化。==

    **把对象作为函数的返回值时，例如：**

    ==Af()== 

    =={  A a;==

      ==......==

      ==return a; //创建一个临时对象，并调用A的拷贝构造函数，==

    ​    ==//用对象a对其进行初始化。==

    ==}==

  * 系统提供的隐式拷贝构造函数将会使得a1和a2的成员指针p指向同一块内存区域！

  * 所以有指针的可能分配到动态内存的类，要自己写一个拷贝构造函数

  * **自定义的拷贝构造函数将默认调用成员对象(成员变量有对象成员)类的默认构造函数对成员对象初始化，如何让其一致？**

  * ![1](/Users/duan/Desktop/AdvancedProgramming/1.jpg)

* ### 常成员，静态成员，友元

  * const成员函数,不能改变类中成员变量的值，如果是指针，可以改变指向区域的值不能改变指针的指向。

    * ==int Date::get_year()const==

      =={.....}//不能改变数据成员的值！==

      ==int Date::get_day()const==

      =={.....}//不能改变数据成员的值！==

      ==intDate::get_month()const==

      =={.....}//不能改变数据成员的值！==

  * 不是常成员函数不能访问常成员变量

  * **静态成员**：可通过静态数据成员来实现属于同一个类的不同对象之间的数据共享

    * ==static int x; //静态数据成员==
    * ==int A::x=0;     //静态数据成员初始化，在类的外部==

  * 类的静态数据成员对该类的所有对象只有一个拷贝。

  * **静态成员函数**：静态成员函数只能访问类的静态成员。静态成员函数没有隐藏的this参数！

  * 静态成员函数可以通过对象来访问外，也可以直接通过类来访问。例如：

    `A a;`

    `......`

    `cout<< a.get_shared();`

    `•或者`

    `cout<< A::get_shared();`  // 这个就有点像全局变量了

  * **友元：**

  * **友元关系具有不对称性。**例如：假设B是A的友元，如果没有显式指出A是B的友元，则A不是B的友元。

    **友元也不具有传递性。**例如：假设B是A的友元、C是B的友元，如果没有显式指出C是A的友元，则C不是A的友元。

    友元是数据保护和数据访问效率之间的一种折衷方案。



## 操作符重载

* C++允许对已有的操作符进行重载，使得它们能对自定义类型（类）的对象进行操作。

* 可以重载C++中除下列操作符外的所有操作符：“. ”， “.* ”，“?: ”，“:: ”，“sizeof ”

* 操作符重载可通过下面两个途径来实现：

  * 作为一个类的非静态的成员函数（new和delete除外）。
  * 作为一个全局（友元）函数。
  * 至少应该有一个参数是类、结构、枚举或它们的引用类型。

* **双目操作符重载：**

  * **作为成员函数重载**：  <返回值类型> operator # (<类型>);//#代表可重载的操作符
    * 使用：a # b或，a.operator#(b)
  * **作为全局函数友元重载**：<返回值类型> operator#(<类型1><参数1> ，<类型2><参数2>) { …... }
    * <类型1>和<类型2>中至少应该有一个是类、结构、枚举或它们的引用类型。
    * 使用格式为：a #b 或 operator#(a,b)

* **单目操作符重载：**

  * **作为成员函数重载**：  <返回值类型> operator ();
    * 使用：\#a 或，a.operator\#()
  * **作为全局函数重**载：<返回值类型> operator #(<类型> <参数>) { …... }
    * 使用：\#a 或 operator#(a)

* **操作符++和--的重载：**

  * 重载++（--）时，如果没有特殊处理，它们的后置用法和前置用法共用同一个重载函数。
  * 为了能够区分++（--）的前置与后置用法，可为它们再写一个重载函数用于实现它们的后置用法，该重载函数应有一个形式上的int型参数。
    *   Counter& operator ++()  //前置的++重载函数
    *   const Counter operator ++(int)  //后置的++重载函数
  * 后置的++函数返回的不是当前现在的对象，因此：
    * ++(++a); (++a)++; //OK
    * ~~++(a++); (a++)++; //Error~~

* **“=”的重载：**

  * ==A a("xyz"),b("abcdefg");==

    ==.......==

    ==a= b;==  

    ==//赋值后，a.p原来所指向的空间成了“孤儿”==

    ==//a和b互相干扰==

    ==//a和b消亡时，"abcdefg"所在的空间将会被释放两次！==

  * 所以要重载=号，就和重写一个拷贝构造函数一样

  * **赋值操作符只能作为非静态的成员函数来重载。不能被继承。**

  * 一般来讲，需要自定义拷贝构造函数的类通常也需要自定义赋值操作符重载函数。

  * 注意：要区别下面两个“=”的不同含义。前者是初始化操作，将调用拷贝构造函数；后者是赋值操作，将调用赋值操作符“=”重载函数。

    ```c++
    A a;
    A b=a; //初始化（等价于：A b(a);），调用拷贝构造函数。
    ......
    b = a; //赋值，调用赋值操作符=重载函数。
    ```

    ​

* **“[]”的重载：**

  * 就是返回下标所指向的元素

  * 如果是二维的呢？

    * ```c++
         int * & operator [](const int & m) {
              return p[m]; //关键在于返回的类型为int *即可
          };
          int & operator ()(const int &m, int const & n) {
              return p[m][n];
          }
      ```

* **new与delete的重载：**

  * 系统提供的new和delete操作所涉及的空间分配和释放是通过系统的堆区管理系统来进行的，效率常常不高。

  * 可以对操作符new和delete进行重载，使得程序能以自己的方式来实现动态对象空间的分配和释放功能。

  * 重载操作符new和delete时，重载的是它们的分配空间和释放空间的功能，不影响对构造函数和析构函数的调用。

  * **n操作符new必须作为静态的成员函数来重载（static说明可以不写），其格式为：**

    * void *operator new(size_tsize); 
    * 返回类型必须为void*
    * 参数表示对象所需空间的大小，其类型为size_t（unsignedint）

  * **使用：**重载的new操作符的使用格式与系统提供的基本相同。例如（假设A中重载了new）：

    * **A*p=new A; **
      * 自动计算A的大小，把它作为参数（size）去调用new的重载函数
      * 调用A类默认构造函数。
    * **A*q=new A(...)**; 
      * 自动计算A的大小，把它作为参数（size）去调用new的重载函数。
      * 调用A类带参数（...）的构造函数。

  * **其他重载new带参数：**

    * 重载new时，除了对象空间大小参数以外，也可以带有其它参数，

      ```c++
      void * operator new(size_tsize,…);
      ```

      如果重载的new包含其它参数，其使用格式为：

      `p= new (…1) A(…2);` 

      …1 表示提供给new重载函数的其它参数

      …2 表示提供给A类构造函数的参数

  * 在非堆区进行对象空间分配的时候不能用delete撤销：

    * ```c++
      void *operator new(size_t size,void *p){	
        return p;
      }

      char buf[sizeof(A)];
      A *p=new (buf) A(0);//动态对象的空间分配为buf
      ......
      p->~A(); //使得p所指向的对象消亡。不能用系统的delete
        
      ```

  * **delete重载：**

    * 操作符delete也必须作为静态的成员函数来重载（static说明可以不写），其格式为：

      ```c++
        void operator delete(void *p, size_tsize);
      ```

      * 返回类型必须为void。
      * 第一个参数类型为void*，指向对象的内存空间。
      * 第二个参数可有可无，如果有，则必须是size_t类型。 
      * 重载后，操作符delete的使用格式与未重载的相同。

* 重载delete和new之后出现的问题：

  * **内存管理问题：**在重载之后，可能需要的存储空间大小不一样，多次申请new之后，出现内存不连续，空余内存放不下心的一个对象。

  * **解决办法：**

    * **重载new**

      * 第一次创建该类的动态对象时，先从系统管理的堆区中申请一块大的空间；
      * 把上述大空间分成若干小块，每个小块的大小为该类一个对象的大小，然后用链表来管理这些小块；
      * 在该链表上为该类对象分配空间

    * **重载delete**

      * 该类的一个对象消亡时，该对象的空间归还到new操作中申请到的大空间（链表）中，而不是归还到系统的堆区中。

    * ```c++
      classA
      {  ...... //类A的已有成员说明。
      public:
        static void *operator new(size_tsize);
        static void operator delete(void *p);
      private:
        A*next; //用于实现A类对象自由空间结点的链接。
        static A *p_free;//用于指向A类对象的自由空间链表头。
      };
      A*A::p_free=NULL;

      const int NUM=32; 
      void *A::operator new(size_t size)
      {	A *p;
      	if (p_free == NULL)
      	{	//申请NUM个A类对象的大空间。
      	  p_free = (A *)malloc(size*NUM);  
      		//在大空间上建立自由结点链表。
      		for (p=p_free; p!=p_free+NUM-1; p++)  
      		   p->next = p+1;
      		p->next = NULL;
      	}
         //从链表中给当前对象分配空间
      	p = p_free;
      	p_free = p_free->next;
      	memset(p,0,size);
      	return p;
      }

      A *q=new A;
      void A::operator delete(void *p) {	
        ((A *)p)->next = p_free;
      	p_free = (A *)p;
      }

      A *q1=new A;
      A *q2=new A;
      delete q1;
      ```

* **动态数组的new与delete：**

  * **动态对象数组的创建与撤销**

    ```c++
    A *p=new A[10];
    ...p[0]、p[1]、...、p[9]...
    delete[] p; //“[]”不能漏掉！
    ```

  * 上述操作将调用下面的重载函数：

    ```c++
    •void * operator new[](size_t size);
    •void operator delete[](void * p);
    ```

    可以自定义上面的重载函数完成特殊的操作。

    •注意：new[]函数的参数size的实际值比对象数组需要的空间多4个字节，用于系统管理！

* **重载函数调用操作符“()”—函数对象：**

  * 函数调用操作符重载主要用于只有一个操作的对象（函数对象，functor），该对象除了具有一般函数的行为外，它还可以拥有状态。例如，下面是一个能产生随机数的对象：

    ```c++
    class Random
    {     
      	unsigned int seed;
      public:
       Random(unsigned inti){ seed = i;}
       unsigned intoperator ()()//函数调用操作符重载
       {
      		seed = (25173*seed+13849)%65536;
           return seed;
       }
    };
    ......
    Random random(1); //创建一个函数对象
    ...random()...//利用函数对象random产生一个随机数
    ```

* **重载类成员访问操作符“->”—智能指针：**

  * “->”为一个双目操作符，其第一个操作数为一个指向类或结构的指针，第二个操作数为第一个操作数所指向的类或结构的成员。n重载“->”时需要按单目操作符重载形式来实现。  

  * func(&a);  ...... //调用完func后，如何知道在func中访问了a多少次？

    * 解决方案一：在每个函数里面都加上一个count++。但是太麻烦

    * 解决方案二：智能指针

      * ```c++
          A *operator ->()  //操作符“->”的重载函数 
          {  
              count++; return p_a;
          }
          int num_of_a_access()const
          {  
              returncount; 
          } 
        ```

      * 这样就只需要一个count++

* 也可以通过给A类的构造函数A(int i)加上一个修饰符explicit，禁止把它当作隐式类型转换符来用：

  *   explicit A(int i) //禁止把它当作隐式类型转换符来用。

  * A a;

    int i=1,z;

    z = a+ i;  //a转换成int



## \lambda表达式

* ```c++
  integrate ([](double x)->double { return x*x; },0,1);
  ```

* 就是一些需要用到简单函数的地方可以写一下lambda表达式

* ```c++
  [<环境变量使用说明>]<形式参数><返回值类型指定><函数体>
  ```

* **<环境变量使用说明>：**指出函数体中对外层作用域中的自动变量的使用限制：

  •空：不能使用外层作用域中的自动变量。

  •&：按引用方式使用外层作用域中的自动变量（可以改变这些变量的值）。

  •=：按值方式使用使用外层作用域中的自动变量（不能改变这些变量的值）。

  •&和=可以用来统一指定对外层作用域中自动变量的使用方式，也可以用来单独指定可使用的外层自动变量（变量名前可以加&，默认为=）。

* 下面是一些合法的λ表达式：

  ```c++
  { 
    int k,m,n;
     ......
     ...[](int x)->int {return x; }... //不能使用k、m、n
     ...[&](int x)->int {k++; m++; n++; return x+k+m+n;}... //k、m、n可以被修改
     ...[=](int x)->int {return x+k+m+n;}... //k、m、n不能被修改
     ...[&,n](int x)->int {k++; m++; return x+k+m+n;}... //n不能被修改
     ...[=,&n](int x)->int {n++; return x+k+m+n;}...  //n可以被修改
     ...[&k,m](int x)->int {k++; return x+k+m;}...   //只能使用k和m，k可以被修改
     ...[] { return k+m+n;}... //没有参数，返回值类型为int，不能使用k、m、n
  }
  ```



##继承

* 派生类除了拥有新定义的成员外，还拥有基类的所有成员（基类的构造函数和赋值操作符重载函数除外）。

* 定义派生类时一定要见到基类的定义。

  ```c++
  class A;  //声明
  class B: public A  //Error
  {  int z;
  public:
     void h() { g(); }  //Error，编译程序不知道基类中
           //是否有函数g以及函数g的原型
  };
  ......
  B b;//Error，编译无法确定b所需内存空间的大小。
  ```

* 实际上，有了继承机制以后，一个类的成员有两种被外界使用的场合：

  ```c++
  class A
  {......
     m
   // 在派生类中使用
  };
  class B: public A
  {......
     f() { ... m...} //通过派生类使用A的成员m
  };
  // 通过类的对象使用
  void g()
  {
    A a;
     ... a.m... //通过A的对象（实例）使用A的成员m
  }
  ```

* 用protected说明的成员不能通过对象使用，但可以在派生类中使用。

* 如果派生类中定义了与基类同名的成员，则基类的成员名在派生类的作用域内不直接可见（被隐藏，Hidden）。访问基类同名成员时要用基类名受限。

  * ```c++
    class B: public A
    {  intz;
    public:
      void f();
      void h()
      {  f();  //B类中的f
         A::f();  //A类中的f
      }
    };

    B b;
    b.f();  //B类中的f
    b.A::f();  //A类中的f
    ```

  * 即使派生类中定义了与基类同名但参数不同的成员函数，基类的同名函数在派生类的作用域中也是不直接可见的，可以用基类名受限方式来使用之

* **继承多态：**

  * 对于具有public继承关系的两个类，在C++中存在下面的多态：
  * 派生类对象的类型既可以是派生类，也可以是基类。（一个对象可以属于多种类型）
  * 基类的指针或引用可以指向或引用基类对象，也可以指向或引用派生类对象。（一个对象标识可以属于多种类型，它可以标识多种对象）
  * 一个可以发送到基类对象的消息，也可以发送到派生类对象，从而可能会得到不同的解释。（消息的多态）。

* **绑定：**

  * **动态绑定：**在C++中用虚函数来实现动态绑定。

  * ```c++
    class A
    {  int x,y;
    public:
      virtual void f();//虚函数
    };

    classB: public A
    {  int z;
    public:
        void f(); //与A类的f是什么关系？
        void g();
    };

    void func1(A& x)
    {	......
    	x.f(); //调用A::f还是B::f ？答案是：A::f或B::f
    	......
    }
    void func2(A *p)
    {	......
    	p->f(); //调用A::f还是B::f ？答案是：A::f或B::f
    	......
    }
    ......
    A a;
    func1(a); //在func1中调用A::f
    func2(&a); //在func2中调用A::f
    B b;
    func1(b); //在func1中调用B::f
    func2(&b); //在func2中调用B::f

    ```

  * **虚函数有两个作用：**

    * 实现消息的动态绑定。
    * 指出基类中可以被派生类重定义的成员函数。

  * **区别：**

    * ```c++
      class A
      {  
      public:
           A f();
           void g();
      };

      class B: public A
      {  
      public:
         A f();//新定义的成员（与A的f无关，同名而已！）
         voidf(int); //新定义的成员
         voidg(); //新定义的成员
      };

      class A
      {	public:
            virtual A f();
            void g();
      };
      class B: public A
      {	public:
      	  A f(); //对A类中成员f的重定义。返回类型也可为B。
      	  void f(int); //新定义的成员
           void g(); //新定义的成员。
      };
      ```

  * **注意⚠️：**

    * 只有类的成员函数才可以是虚函数，但静态成员函数不能是虚函数。
    * 构造函数不能是虚函数，析构函数可以（往往）是虚函数。
    * 只有通过基类的指针或引用访问基类的虚函数时才进行动态绑定。
    * 基类的构造函数中对虚函数的调用不进行动态绑定。（为什么？）
      * 析构函数如果不是虚函数，会出现问题。一直调用的都是基类的析构函数，一直在释放本来不是该对象生成的new堆

  * ```c++
    class A
    {  ......
    public:
        A() { f();}
        ~A();
        virtual void f();
        void g();
        void h() { f(); g(); }
      };

      class B: public A
      {  .......
       public:
         B() { ...... }
        ~B();
        void f(); 
        void g(); 
      };
    ......
    A a;    //调用A::A()和A::f
    a.f();  //调用A::f
    a.g();  //调用A::g
    a.h();  //调用A::h、A::f和A::g
    //a消亡时会调用A::~A()

    B b;    //调用B::B(), A::A()和A::f
    b.f();  //调用B::f
    b.g();  //调用B::g
    b.h();  //调用A::h、B::f和A::g
    //b消亡时会调用A::~A()和B::~B()

    A *p;
    p = &a;
    p->f();  //调用A::f
    p->g();  //调用A::g
    p->h();  //调用A::h, A::f和A::g
    p = &b;
    p->f();  //调用B::f
    p->A::f(); //调用A::f
    p->g();  //调用A::g，非虚函数采用静态绑定
    p->h();  //调用A::h, B::f和A::g
    p = new A;  //调用A::A()和A::f
    .......
    delete p;  //调用A::~A()
    p = new B;  //调用B::B(), A::A()和A::f
    .......
    delete p;  //只调用A::~A()，不调用B:~B()
                   //为什么？
                     //没有把A的析构函数定义为虚函数！
    ```

    * 上面的b.h()调用的B::f 因为f是有virtual 是动态绑定
    * p->g();  //调用A::g，非虚函数采用静态绑定

  * ```c++
    class A
    {        .......
    public:
      virtual void f();
    };

    class B: public A
    {        ......
    public:
      void f();
      void g(); 
    };

    A*p=new B;
    ......
    p->f();//OK
    p->g();//Error
    ((B*)p)->g(); //OK，不安全！
    ```

* **聚集：**

  * 聚集就是在一个类中定义另一个类，聚集会使得继承产生的矛盾得以解决

* **多继承：**

  * 多继承有冲突，其实不太建议

* **多次继承之后产生的重复继承：**

  * 下面的类D从类A继承两次，称为重复继承：

    ```c++
    class A
      { int x;
        ......
      };

      class B: public A { ... };
      class C: public A { ... };
      class D: public B, public C { ...};
      // 上面D类的对象d将包含两个x：
      // B::x和C::x
    ```

  * 如果要求类D中只有一个x，则应把A定义为B和C的虚基类：

    ```c++
      class B: virtual public A {...};
      class C: virtual public A {...};
      class D: public B, public C {...};
    ```

    虚基类的实现不能简单地去除一个x，而是存一个x的偏移，要不整体的内存地址都乱掉了



##泛型

* 类型参数，然后实例化

* 除了类型参数外，类模板也可以包括非类型参数。例如：

  * ```c++
    template <class T,intsize> 
    class Stack
    {  T buffer[size];
      int top;
    public:
      Stack() { top = -1; }
      bool push(const T &x);
      bool pop(T &x);
    };

    template <class T,int size> 
    bool Stack <T,size>::push(const T&x) { ...... }
    template <class T, int size> 
    bool Stack <T,size>::pop(T&x) { ...... }
    ......
    Stack<int,100>st1; //st1为元素个数最多为100的int型栈
    Stack<int,200>st2; //st2为元素个数最多为200的int型栈
    ```



## STL

* **vector<元素类型>：**

  * 用于需要快速定位（访问）任意位置上的元素以及主要在元素序列的尾部增加/删除元素的场合。
  * 在头文件vector中定义，用动态数组实现。

* **list<元素类型>：**

  * 用于经常在元素序列中任意位置上插入/删除元素的场合。
  * 在头文件list中定义，用双向链表实现。

* **deque<元素类型>：**

  * 用于主要在元素序列的两端增加/删除元素以及需要快速定位（访问）任意位置上的元素的场合。
  * 在头文件deque中定义，用分段的连续空间结构实现。

* **stack<元素类型>：**

  * 用于仅在元素序列的尾部增加/删除元素的场合。
  * 在头文件stack中定义，一般基于deque来实现。

* **queue<元素类型>：**

  * 用于仅在元素序列的尾部增加、头部删除元素的场合。
  * 在头文件queue中定义，一般基于deque来实现。

* **priority_queue<元素类型>：**

  * 它与queue的操作类似，不同之处在于：每次增加/删除元素之后，它将对元素位置进行调整，使得头部元素总是最大的。也就是说，每次删除操作总是把最大（优先级最高）的元素去掉。
  * 在头文件queue中定义，一般基于vector和heap结构来实现。

* **map<关键字类型，值类型>和multimap<关键字类型，值类型>：**

  * 容器中每个元素是一个pair结构类型，该结构有两个成员：first和second，关键字对应first，值对应second，元素是根据其关键字排序的。用于需要根据关键字来访问元素的场合。
  * 对于map，不同元素的关键字不能相同；对于multimap，不同元素的关键字可以相同。
  * 它们在头文件map中定义，常常用某种二叉树来实现。

* **set<元素类型>和multiset<元素类型>**

  * 它们分别是map和multimap的特例，每个元素只有关键字而没有值，或者说，关键字与值合一了。
  * 在头文件set中定义。

* **basic_string<字符类型>**

  * 与vector类似，不同之处在于其元素为字符类型，并提供了一系列与字符串相关的操作。
  * string和wstring分别是它的两个实例：basic_string<char>和basic_string<wchar_t>。
  * 在头文件string中定义。

* **迭代器：**

  * 迭代器（iterator）实现了抽象的指针（智能指针），它们指向容器中的元素，用于对容器中的元素进行访问和遍历。
  * 在STL中，迭代器是作为类模板来实现的，它们可分为以下几种：
    * **输出迭代器（outputiterator，记为：OutIt）**
      * 用于修改它所指向的容器元素
      * 间接访问操作（*）：*<输出迭代器>= ...
      * ++操作
    * **输入迭代器（inputiterator，记为：InIt）**
      * 用于读取它所指向的容器元素
      * 间接访问操作（*）：... =*<输入迭代器>
      * 元素成员间接访问（->）
      * ++、==、!=操作。
    * **前向迭代器（forwarditerator，记为：FwdIt）**
      * 用于读取/修改它所指向的容器元素
      * 元素间接访问操作（*）和元素成员间接访问操作（->
      * n++、==、!=操作
    * **双向迭代器（bidirectionaliterator，记为：BidIt）**
      * 用于读取/修改它所指向的容器元素
      * 元素间接访问操作（*）和元素成员间接访问操作（->）
      * ++、--、==、!=操作
    * **随机访问迭代器（random-accessiterator，记为：RanIt）**
      * 用于读取/修改它所指向的容器元素
      * 元素间接访问操作（*）、元素成员间接访问操作（->）和随机访问元素操作（[]）
      * n++、--、+、-、+=、-=、==、!=、<、>、<=、>=操作
    * **对于vector、deque以及basic_string容器类，成员函数begin/end返回的是随机访问迭代器（RanIt）**
    * **对于list、map/multimap以及set/multiset，成员函数begin/end则返回的是双向迭代器（BidIt）。**
    * **对于queue、stack和priority_queue ，不支持迭代器！**

* **算法：**

  * ```c++
    bool f(int x) {return x > 0; }
    vector<int>v;
    ......//往容器中放了元素
    cout<<count_if(v.begin(),v.end(),f); //统计v中正数的个数

    void sort(RanIt first, RanIt last, BinPred less); 

    void f(int x) { cout << x << ' '; }
    vector<int> v;
    ...... //往容器中放了元素
    for_each(v.begin(),v.end(),f); //对v中的每个元素去调用函数f进行操作

    int f1(int partial, int x) { return partial*x; }
    int f2(int partial, int x) { return partial+x*x; }
    double f3(double partial, int x) { return partial+1.0/x; }
    vector<int> v;
    ...... //往容器中放了元素
    accumulate(v.begin(),v.end(),0); //所有元素和
    accumulate(v.begin(),v.end(),1,f1); //所有元素的乘积
    accumulate(v.begin(),v.end(),0,f2); //所有元素平方和
    accumulate(v.begin(),v.end(),0.0,f3); //所有元素倒数和

    int f1(int x) { return x*x; }
    int f2(int x1, int x2) { return x1+x2; }
    vector<int> v1,v2,v3;
    ...... //往容器中放了元素
    transform(v1.begin(),v1.end(),v3.begin(),f1); 
    				//v3中的元素是v1相应元素的平方
    transform(v1.begin(),v1.end(),v2.begin(),v3.begin(),f2); 
    				//v3中的元素是v1和v2相应元素的和
    ```



## 面向对象的I/O

* **面向控制台的I/O（iostream）：**
  * 从标准输入设备（如：键盘）获得数据
  * 把程序结果从标准输出设备（如：显示器）输出
* **面向文件的I/O（fstream）：**
  * 从外存文件获得数据
  * 把程序结果保存到外存文件中
* **面向字符串变量的I/O（sstream）：**
  * 从程序中的字符串变量中获得数据
  * 把程序结果保存到字符串变量中
* **最后一个数据的换行问题：**
  * http://blog.csdn.net/vitalia/article/details/74298866



##转移构造函数&转移赋值操作符重载函数

* 在创建一个对象时用另一个同类型的对象对其初始化时，将会调用拷贝构造函数。当用一个临时或即将消亡的对象去初始化另一个同类的对象时，目前的拷贝构造函数的实现效率有时是不高的。

* 也就是在返回的时候，如果这个时候利用拷贝构造函数，仍旧效率不高，还要再使用新的地址，为什么不把对象t申请的空间直接带到返回值对象中呢？

* 因此在C++ 11 中出现了拷贝构造函数：

  * ```c++
    A(A&& x); //参数类型为右值引用类型：&&
    ```

* ```c++
  A(A&&x) //参数类型为右值引用类型&&
  { 
    p =x.p; //把参数对象x的p所指向的空间作为新对象的p所指向的空间（资源转移）
    x.p = NULL; //使得参数对象x的p不再拥有原来所指向的空间。
  }
  ```

* 把一个对象赋值给另一个对象时，将会去调用对象类的赋值操作符重载函数。当用于赋值的对象是一个临时或即将消亡的对象时，目前的赋值操作符重载函数的实现效率有时是不高的。

* 同上述，转移赋值操作符重载：

  * ```c++
    A & operator=(A&& x) //参数类型为右值引用：&&
      
    A & operator=(A&& x) //参数类型为右值引用
    { if (&x == this) return *this;
       delete []p; //归还老空间
       p = x.p; //使用参数对象的空间（资源转移）
       x.p = NULL; //使得参数对象不再拥有空间
       return *this; 
     }
    ```



## 异常处理

* **异常的就地处理：**

  * 常用做法是调用C++标准库中的函数exit或abort终止程序执行（在cstdlib或stdlib.h中声明）
  * abort立即终止程序的执行，不作任何的善后处理工作。
  * exit在终止程序的运行前，会做关闭被程序打开的文件、调用全局对象和static存储类的局部对象的析构函数（注意：不要在这些对象类的析构函数中调用exit，要不会导致exit调用析构函数，析构函数调用exit的递归调用）等工作。

* **异常的异地处理：**

  * 发现异常时，在发现地（如在被调用的函数中）有时不知道如何处理这个异常，或者不能很好地处理这个异常，要由程序的其它地方（如函数的调用者）来处理。

  * 一种解决办法是返回一个值，然后自己判断，该途径的不足：

    * 通过函数的返回值返回异常情况会导致正常返回值和异常返回值交织在一起。
    * 通过指针/引用类型的参数返回异常情况，需要引入额外的参数，给设计带来负担。
    * 通过全局变量返回异常情况会导致使用者忽视这个全局变量的问题。（不知道它的存在）
    * 程序的可读性差！程序的正常处理与异常处理混杂在一起。

  * 另一种解决途径就是结构化异常处理：

    * 把有可能遭遇异常的一系列操作（语句或函数调用）构成一个try语句块。

    * 如果try语句块中的某个操作在执行中发现了异常，则通过执行一个throw语句抛掷（产生）一个异常对象，之后的操作不再进行。

    * 抛掷的异常对象将由能够处理这个异常的地方通过catch语句块来捕获并处理之。

    *  

      ```c++
        if (file.fail())
      	throw filename;//产生异常对象，报告错误情况

          try { f(str); } //启动异常处理机制
          catch (char *fn) //捕获异常
          { ...... //处理异常
          }
          ...... 
      ```

      ​

